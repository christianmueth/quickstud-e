import { spawn } from "child_process";
import { writeFileSync, mkdirSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";

export interface SubtitleTrack {
  language: string;
  isAutoGenerated: boolean;
  format: string;
}

/**
 * Download subtitles using yt-dlp
 * Returns the path to the downloaded subtitle file
 */
export async function downloadYouTubeSubtitles(
  videoId: string,
  options: {
    lang?: string;
    format?: "vtt" | "srt" | "json3";
    preferAutoGenerated?: boolean;
  } = {}
): Promise<string> {
  const { lang = "en", format = "vtt", preferAutoGenerated = true } = options;

  const tmpDir = join(tmpdir(), "quickstud-subs");
  mkdirSync(tmpDir, { recursive: true });

  const outputTemplate = join(tmpDir, `${videoId}.%(ext)s`);
  
  const args = [
    "--write-auto-sub",  // Get auto-generated subs
    "--sub-lang", lang,
    "--sub-format", format,
    "--skip-download",   // Don't download video
    "--no-warnings",
    "-o", outputTemplate,
    `https://www.youtube.com/watch?v=${videoId}`
  ];

  return new Promise((resolve, reject) => {
    // Try to use yt-dlp (preferred) or fall back to youtube-dl
    const proc = spawn("yt-dlp", args, { stdio: ["ignore", "pipe", "pipe"] });
    
    let stdout = "";
    let stderr = "";

    proc.stdout?.on("data", (data) => {
      stdout += data.toString();
    });

    proc.stderr?.on("data", (data) => {
      stderr += data.toString();
    });

    proc.on("error", (err) => {
      // If yt-dlp not found, try youtube-dl
      if (err.message.includes("ENOENT")) {
        const fallbackProc = spawn("youtube-dl", args, { stdio: ["ignore", "pipe", "pipe"] });
        
        fallbackProc.on("error", () => {
          reject(new Error("Neither yt-dlp nor youtube-dl found. Install with: pip install yt-dlp"));
        });

        fallbackProc.on("close", (code) => {
          if (code === 0) {
            const subtitlePath = join(tmpDir, `${videoId}.${lang}.${format}`);
            resolve(subtitlePath);
          } else {
            reject(new Error("youtube-dl failed to download subtitles"));
          }
        });
      } else {
        reject(err);
      }
    });

    proc.on("close", (code) => {
      if (code === 0) {
        // yt-dlp creates files like: videoId.lang.format
        const subtitlePath = join(tmpDir, `${videoId}.${lang}.${format}`);
        resolve(subtitlePath);
      } else {
        reject(new Error(`yt-dlp exited with code ${code}\nStderr: ${stderr}`));
      }
    });
  });
}

/**
 * Parse VTT subtitle file into normalized cues
 */
export function parseVTT(vttContent: string): Array<{ startMs: number; endMs: number; text: string }> {
  const lines = vttContent.split("\n");
  const cues: Array<{ startMs: number; endMs: number; text: string }> = [];
  
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    
    // Look for timestamp line (e.g., "00:00:00.000 --> 00:00:03.000")
    if (line.includes("-->")) {
      const [startStr, endStr] = line.split("-->").map(s => s.trim());
      const startMs = parseVTTTimestamp(startStr);
      const endMs = parseVTTTimestamp(endStr);
      
      // Collect text lines until we hit an empty line
      i++;
      const textLines: string[] = [];
      while (i < lines.length && lines[i].trim()) {
        textLines.push(lines[i].trim());
        i++;
      }
      
      if (textLines.length > 0) {
        cues.push({
          startMs,
          endMs,
          text: textLines.join(" ").replace(/<[^>]+>/g, "") // Strip VTT tags
        });
      }
    }
    i++;
  }
  
  return cues;
}

/**
 * Parse SRT subtitle file into normalized cues
 */
export function parseSRT(srtContent: string): Array<{ startMs: number; endMs: number; text: string }> {
  const lines = srtContent.split("\n");
  const cues: Array<{ startMs: number; endMs: number; text: string }> = [];
  
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    
    // Look for timestamp line (e.g., "00:00:00,000 --> 00:00:03,000")
    if (line.includes("-->")) {
      const [startStr, endStr] = line.split("-->").map(s => s.trim());
      const startMs = parseSRTTimestamp(startStr);
      const endMs = parseSRTTimestamp(endStr);
      
      // Collect text lines until we hit an empty line
      i++;
      const textLines: string[] = [];
      while (i < lines.length && lines[i].trim()) {
        textLines.push(lines[i].trim());
        i++;
      }
      
      if (textLines.length > 0) {
        cues.push({
          startMs,
          endMs,
          text: textLines.join(" ").replace(/<[^>]+>/g, "") // Strip tags
        });
      }
    }
    i++;
  }
  
  return cues;
}

function parseVTTTimestamp(timestamp: string): number {
  // Format: HH:MM:SS.mmm or MM:SS.mmm
  const parts = timestamp.split(":");
  let hours = 0, minutes = 0, seconds = 0;
  
  if (parts.length === 3) {
    hours = parseInt(parts[0]);
    minutes = parseInt(parts[1]);
    seconds = parseFloat(parts[2]);
  } else if (parts.length === 2) {
    minutes = parseInt(parts[0]);
    seconds = parseFloat(parts[1]);
  }
  
  return Math.round((hours * 3600 + minutes * 60 + seconds) * 1000);
}

function parseSRTTimestamp(timestamp: string): number {
  // Format: HH:MM:SS,mmm
  const [time, ms] = timestamp.split(",");
  const [hours, minutes, seconds] = time.split(":").map(Number);
  return Math.round((hours * 3600 + minutes * 60 + seconds) * 1000 + parseInt(ms || "0"));
}